import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

colors = ['red', 'blue', 'yellow', 'green', 'cyan', 'violet']

def _applyCosmetics(title, xlabel, ylabel, xlimits, ylimits, legendLocation):
	plt.xlabel(xlabel)
	plt.ylabel(ylabel)
	if not legendLocation is None:
		plt.legend(loc=legendLocation)
	if xlimits:
		plt.xlim(xlimits[0], xlimits[1])
	if title:
		plt.title(title)
	if ylimits[0] != ylimits[1]:
		yrange = ylimits[1] - ylimits[0]
		plt.ylim(ylimits[0]-0.05*yrange, ylimits[1]+0.05*yrange)

def plotAverageTimeSeries(samplesDict, ylabel, outFile, title=None,
	strips='conf95', xlabel='Time', xlimit=None, disableStrips=False,
	legendLocation=4, dpi=300, figsize=None):
	'''Plots averages of several random time series. The samples must represented
     as a numpy matrix (each row is a sample) and stored as values in the
	   samplesDict dictionary. The keys of the dictionary will be used to annotate
	   the plot via legend. Error data is provided in the form of strips
	   surrounding each everage plot. What exactly the strip represents is
	   controlled by the strips option:
	     strips='conf95' (default) - 95% confidence interval (gaussian assumption)
	     strips='stderr' - raw standard error of the sum
	  Strips can be disabled by setting disableStrips to true, in which case they
	  are going to be replaced with errorbars around the points. This is useful
	  when the xlimit is low.
		The output is written in PNG format to outFile.
	'''
	import stats
	colorIdx = 0
	limits = [np.inf, -np.inf]
	for tsname, tssamples in samplesDict.items():
		tsavg = np.mean(tssamples, axis=0)
		tsstderr = stats.timeSeriesStderr(tssamples)
		if strips == 'conf95':
			tsstderr *= 1.96
		elif strips == 'stderr':
			pass
		else:
			raise ValueError('Unsupported strip type {}. Supported types: conf95, stderr'.format(strips))
		lower = tsavg - tsstderr
		upper = tsavg + tsstderr
		limits = [ min(limits[0], min(lower)), max(limits[1], max(upper)) ]

		time = np.arange(0,len(tsavg))
		if disableStrips:
			plt.errorbar(time, tsavg, color=colors[colorIdx], yerr=tsstderr, label=tsname)
		else:
			plt.plot(time, lower, time, upper, color=colors[colorIdx], alpha=0.5)
			plt.fill_between(time, lower, upper, where=upper>=lower, facecolor=colors[colorIdx], alpha=0.3, interpolate=True)
			plt.plot(time, tsavg, color=colors[colorIdx], label=tsname)

		colorIdx += 1
	_applyCosmetics(title, xlabel, ylabel, [0, xlimit] if xlimit else None, limits, legendLocation)

	fig = matplotlib.pyplot.gcf()
	if figsize:
		fig.set_size_inches(figsize[0], figsize[0])
	fig.savefig(outFile, dpi=dpi)
	plt.close()

def plotAllTimeSeries(samplesDict, ylabel, outFile, title=None,
	xlabel='Time', xlimit=None, legendLocation=4, dpi=300, alpha=0.1, figsize=None):
	'''Generates a plot of all time series generated by several processes. The
	   time series samples must represented as numpy matrices (each row is a
	   time series) and stored as values in the samplesDict dictionary. The keys
	   of the dictionary will be interpreted as generating processes' labels and
	   used to annotate the plot via legend.
		The output is written in PNG format to outFile.
	'''
	colorIdx = 0
	limits = [np.inf, -np.inf]
	for tsname, tssamples in samplesDict.items():
		limits = [ min(limits[0], np.min(tssamples)), max(limits[1], np.max(tssamples)) ]
		time = np.arange(0, tssamples.shape[1])
		plt.plot(time, tssamples[0,:], color=colors[colorIdx], alpha=alpha, label=tsname)
		for trajIdx in range(1, tssamples.shape[0]):
			plt.plot(time, tssamples[trajIdx,:], color=colors[colorIdx], alpha=alpha)

		colorIdx += 1
	_applyCosmetics(title, xlabel, ylabel, [0, xlimit] if xlimit else None, limits, legendLocation)

	fig = matplotlib.pyplot.gcf()
	if figsize:
		fig.set_size_inches(figsize[0], figsize[0])
	fig.savefig(outFile, dpi=dpi)
	plt.close()
